// Input validation schemas and utilities\n\n// Basic validation utilities\nexport class ValidationError extends Error {\n  public field: string;\n  public code: string;\n\n  constructor(field: string, message: string, code = 'VALIDATION_ERROR') {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n    this.code = code;\n  }\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: ValidationError[];\n  data?: unknown;\n}\n\n// Email validation\nexport const validateEmail = (email: string): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  if (!email) {\n    errors.push(new ValidationError('email', 'Email is required'));\n  } else {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      errors.push(new ValidationError('email', 'Please enter a valid email address'));\n    }\n    if (email.length > 254) {\n      errors.push(new ValidationError('email', 'Email address is too long'));\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: email?.toLowerCase().trim(),\n  };\n};\n\n// Password validation\nexport const validatePassword = (password: string): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  if (!password) {\n    errors.push(new ValidationError('password', 'Password is required'));\n  } else {\n    if (password.length < 8) {\n      errors.push(new ValidationError('password', 'Password must be at least 8 characters long'));\n    }\n    if (password.length > 128) {\n      errors.push(new ValidationError('password', 'Password must be less than 128 characters'));\n    }\n    if (!/(?=.*[a-z])/.test(password)) {\n      errors.push(new ValidationError('password', 'Password must contain at least one lowercase letter'));\n    }\n    if (!/(?=.*[A-Z])/.test(password)) {\n      errors.push(new ValidationError('password', 'Password must contain at least one uppercase letter'));\n    }\n    if (!/(?=.*\\d)/.test(password)) {\n      errors.push(new ValidationError('password', 'Password must contain at least one number'));\n    }\n    if (!/(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?])/.test(password)) {\n      errors.push(new ValidationError('password', 'Password must contain at least one special character'));\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: password,\n  };\n};\n\n// Name validation\nexport const validateName = (name: string): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  if (!name) {\n    errors.push(new ValidationError('name', 'Name is required'));\n  } else {\n    const trimmedName = name.trim();\n    if (trimmedName.length < 2) {\n      errors.push(new ValidationError('name', 'Name must be at least 2 characters long'));\n    }\n    if (trimmedName.length > 50) {\n      errors.push(new ValidationError('name', 'Name must be less than 50 characters'));\n    }\n    if (!/^[a-zA-Z\\s'-]+$/.test(trimmedName)) {\n      errors.push(new ValidationError('name', 'Name can only contain letters, spaces, hyphens, and apostrophes'));\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: name?.trim(),\n  };\n};\n\n// Workflow name validation\nexport const validateWorkflowName = (name: string): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  if (!name) {\n    errors.push(new ValidationError('name', 'Workflow name is required'));\n  } else {\n    const trimmedName = name.trim();\n    if (trimmedName.length < 3) {\n      errors.push(new ValidationError('name', 'Workflow name must be at least 3 characters long'));\n    }\n    if (trimmedName.length > 100) {\n      errors.push(new ValidationError('name', 'Workflow name must be less than 100 characters'));\n    }\n    if (!/^[a-zA-Z0-9\\s_-]+$/.test(trimmedName)) {\n      errors.push(new ValidationError('name', 'Workflow name can only contain letters, numbers, spaces, underscores, and hyphens'));\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: name?.trim(),\n  };\n};\n\n// URL validation\nexport const validateUrl = (url: string, required = false): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  if (!url) {\n    if (required) {\n      errors.push(new ValidationError('url', 'URL is required'));\n    }\n  } else {\n    try {\n      new URL(url);\n      // Additional security checks\n      const parsedUrl = new URL(url);\n      if (!['http:', 'https:'].includes(parsedUrl.protocol)) {\n        errors.push(new ValidationError('url', 'URL must use HTTP or HTTPS protocol'));\n      }\n    } catch {\n      errors.push(new ValidationError('url', 'Please enter a valid URL'));\n    }\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: url?.trim(),\n  };\n};\n\n// JSON validation\nexport const validateJson = (jsonString: string, required = false): ValidationResult => {\n  const errors: ValidationError[] = [];\n  let parsedData;\n  \n  if (!jsonString) {\n    if (required) {\n      errors.push(new ValidationError('json', 'JSON is required'));\n    }\n    return { isValid: !required, errors };\n  }\n  \n  try {\n    parsedData = JSON.parse(jsonString);\n  } catch {\n    errors.push(new ValidationError('json', 'Invalid JSON format'));\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: parsedData,\n  };\n};\n\n// Sanitization utilities\nexport const sanitizeHtml = (input: string): string => {\n  // Basic HTML sanitization - in production, use a library like DOMPurify\n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/\\//g, '&#x2F;');\n};\n\nexport const sanitizeString = (input: string, maxLength = 1000): string => {\n  if (!input) return '';\n  \n  return input\n    .trim()\n    .slice(0, maxLength)\n    .replace(/[\\x00-\\x1F\\x7F]/g, ''); // Remove control characters\n};\n\n// Composite validation for forms\nexport const validateLoginForm = (email: string, password: string): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  const emailResult = validateEmail(email);\n  const passwordResult = validatePassword(password);\n  \n  errors.push(...emailResult.errors, ...passwordResult.errors);\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: {\n      email: emailResult.data,\n      password: passwordResult.data,\n    },\n  };\n};\n\nexport const validateSignupForm = (\n  email: string,\n  password: string,\n  confirmPassword: string,\n  name?: string\n): ValidationResult => {\n  const errors: ValidationError[] = [];\n  \n  const emailResult = validateEmail(email);\n  const passwordResult = validatePassword(password);\n  const nameResult = name ? validateName(name) : { isValid: true, errors: [], data: undefined };\n  \n  errors.push(...emailResult.errors, ...passwordResult.errors, ...nameResult.errors);\n  \n  // Check password confirmation\n  if (password !== confirmPassword) {\n    errors.push(new ValidationError('confirmPassword', 'Passwords do not match'));\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    data: {\n      email: emailResult.data,\n      password: passwordResult.data,\n      name: nameResult.data,\n    },\n  };\n};\n\n// Rate limiting helper\nexport class RateLimiter {\n  private attempts: Map<string, number[]> = new Map();\n  \n  constructor(\n    private maxAttempts = 5,\n    private windowMs = 15 * 60 * 1000 // 15 minutes\n  ) {}\n  \n  isAllowed(identifier: string): boolean {\n    const now = Date.now();\n    const userAttempts = this.attempts.get(identifier) || [];\n    \n    // Remove old attempts outside the time window\n    const recentAttempts = userAttempts.filter(time => now - time < this.windowMs);\n    \n    if (recentAttempts.length >= this.maxAttempts) {\n      return false;\n    }\n    \n    // Record this attempt\n    recentAttempts.push(now);\n    this.attempts.set(identifier, recentAttempts);\n    \n    return true;\n  }\n  \n  getRemainingTime(identifier: string): number {\n    const userAttempts = this.attempts.get(identifier) || [];\n    if (userAttempts.length === 0) return 0;\n    \n    const oldestAttempt = Math.min(...userAttempts);\n    const remainingTime = this.windowMs - (Date.now() - oldestAttempt);\n    \n    return Math.max(0, remainingTime);\n  }\n}\n\n// Export default rate limiter instance\nexport const authRateLimiter = new RateLimiter(5, 15 * 60 * 1000); // 5 attempts per 15 minutes"